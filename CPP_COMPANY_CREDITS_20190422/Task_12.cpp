#include <iostream>

namespace Task_12
{
//static часто используетс€ дл€ того, чтобы "скрыть" метод в единице трансл€ции,
//т.е.в начале.c файла объ€вл€ютс€ static функции и переменные и они будут
//доступны только в этом файле.
//ƒаже объ€вив где-то точно такой же прототип ты из другого .c файла 
//не получишь доступ к этим функци€м.
static void foo(int a, int b)//«ачем static?
{
	std::cout << a << " " << b << std::endl;
}

int Main()
{
	int i = 0;

	foo(++i, i++);//–езультат не определЄн:  2, 0 или 1, 1. C++ не определ€ет пор€док, в котором вычисл€ютс€ аргументы функции.

	std::cout << i << std::endl;

	return 0;
}

}

////////////////////////////////////////////////////////////////////
//int add(int x, int y)
//{
//	return x + y;
//}

//int main()
//{
//	int x = 5;
//	int value = add(x, ++x); // здесь 5 + 6 или 6 + 6?  Ёто зависит от компил€тора и в каком пор€дке он будет обрабатывать аргументы функции 
//}
//C++ не определ€ет пор€док, в котором вычисл€ютс€ аргументы функции.
//≈сли левый аргумент будет вычисл€тьс€ первым, то add(5, 6) и результат Ч 11.
//≈сли правый аргумент будет вычисл€тьс€ первым, то add(6, 6) и результат Ч 12!
//ј проблема то кроетс€ в побочном эффекте одного из аргументов функции add().
//https://ravesli.com/urok-40-inkrement-dekrement-pobochnye-effekty/
////////////////////////////////////////////////////////////////////
