#include <iostream>

class Fraction
{
private:
	int m_numerator;
	int m_denominator;

public:
	Fraction(int numerator = 0, int denominator = 1) :
		m_numerator(numerator), m_denominator(denominator)
	{
	}

	friend std::ostream& operator<<(std::ostream& out, const Fraction& f1)
	{
		out << f1.m_numerator << "/" << f1.m_denominator;
		return out;
	}
};

void UnitTest_Ref()
{
	std::cout << "UnitTest_Ref" << std::endl;

	{
		//В C++11 добавили новый тип ссылок — ссылки r-value.
		//Ссылки r-value — это ссылки, которые инициализируются только значениями r-values.
		//Хотя ссылка l-value создается с использованием одного амперсанда, ссылка r-value 
		//создается с использованием двойного амперсанда:
		int x = 7;
		int& lref = x; // инициализация ссылки l-value переменной x (значение l-value)
		int&& rref = 7; // инициализация ссылки r-value литералом 7 (значение r-value)

		rref = 5;

		rref = x;//какое-то странное неявное преобразование...!!! при изменении x - rref

		//int y;
		//rref = y;//ER: using uninitialized memory "y"

		//int&& rref2 = x;//ER: rvalue reference cannot be bound to an lvalue
		//const int&& rref3 = x;//ER: rvalue reference cannot be bound to an lvalue

		std::cout << lref << " " << rref << std::endl;

		//Ссылки r-value имеют два полезных свойства:
		//
		// 1. Они увеличивают продолжительность жизни объекта, которым инициализируются,
		//    до продолжительности жизни ссылки r-value (ссылки l-value на константные объекты
		//    также могут это делать).
		//
		// 2. Неконстантные ссылки r-value позволяют нам изменять значения r-values,
		//    на которые указывают ссылки r-value!
	}

	{
		Fraction&& rref = Fraction(4, 7); // ссылка r-value на анонимный объект класса Fraction

		std::cout << rref << '\n';

		//Создаваемый анонимный объект Fraction(4, 7) обычно вышел бы из области видимости
		//в конце выражения, в котором он определен.Однако, так как мы инициализируем
		//ссылку r-value этим анонимным объектом, то его продолжительность жизни
		//увеличивается до продолжительности жизни самой ссылки r-value, т.е. до конца
		//блока.
		//Затем мы используем ссылку r-value для вывода значения анонимного объекта
		//класса Fraction.

	}// rref (и анонимный объект класса Fraction) выходят из области видимости здесь

	{
		int&& rref = 7; // поскольку мы инициализируем ссылку r-value литералом 7, то создается временный объект со значением 7, на который указывает ссылка r-value

		rref = 12;

		std::cout << rref;

		//Хотя это может показаться странным, но при инициализации ссылки r-value литералом,
		//создается временный объект, на который ссылается ссылка r-value (она не ссылается на сам литерал).

		//Ссылки r-value не очень часто используются так, как это представлено в примерах выше.
	}

	{
		const int& ref4 = 7; // D
	}
}

//Возврат ссылки r-value

//Вы почти никогда не должны возвращать ссылку r-value из функции по той же причине,
//по которой вы почти никогда не должны возвращать ссылку l-value из функции.
//В большинстве случаев вы будете возвращать висячую ссылку(указывающую на удаленную
//память), а объект, на который будет ссылаться ссылка — выйдет из области видимости
//в конце функции.